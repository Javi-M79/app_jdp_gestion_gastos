package com.example.app_jdp_gestion_gastos.data.repositoryimport android.util.Logimport androidx.lifecycle.getimport com.example.app_jdp_gestion_gastos.data.model.Expenseimport com.example.app_jdp_gestion_gastos.data.model.Groupimport com.example.app_jdp_gestion_gastos.data.model.Incomeimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.firestore.FieldPathimport com.google.firebase.firestore.FirebaseFirestoreimport kotlinx.coroutines.tasks.awaitclass StatsRepository {    private val db = FirebaseFirestore.getInstance()    // Obtiene gastos filtrando por grupo si se pasa groupId    suspend fun getExpenses(groupId: String? = null): List<Expense> {        return try {            if (groupId != null) {                // Obtener el grupo para sacar sus miembros (emails)                val groupSnapshot = db.collection("groups").document(groupId).get().await()                val group = groupSnapshot.toObject(Group::class.java)                val membersEmails = group?.members ?: emptyList()                if (membersEmails.isEmpty()) return emptyList()                // Ahora hay que obtener userIds de esos emails para buscar expenses                val userIds = getUserIdsFromEmails(membersEmails)                if (userIds.isEmpty()) return emptyList()                val expensesList = mutableListOf<Expense>()                val batchSize = 10                for (i in userIds.indices step batchSize) {                    val batch = userIds.subList(i, kotlin.math.min(i + batchSize, userIds.size))                    val querySnapshot = db.collection("expenses")                        .whereIn("userId", batch)                        .get()                        .await()                    expensesList.addAll(querySnapshot.toObjects(Expense::class.java))                }                expensesList            } else {                // Usuario actual                val currentUserId = FirebaseAuth.getInstance().currentUser?.uid ?: return emptyList()                val querySnapshot = db.collection("expenses")                    .whereEqualTo("userId", currentUserId)                    .get()                    .await()                querySnapshot.toObjects(Expense::class.java)            }        } catch (e: Exception) {            Log.e("StatsRepository", "Error al obtener los gastos", e)            emptyList()        }    }    // Igual que getExpenses pero para ingresos    suspend fun getIncomes(groupId: String? = null): List<Income> {        return try {            if (groupId != null) {                val groupSnapshot = db.collection("groups").document(groupId).get().await()                val group = groupSnapshot.toObject(Group::class.java)                val membersEmails = group?.members ?: emptyList()                if (membersEmails.isEmpty()) return emptyList()                val userIds = getUserIdsFromEmails(membersEmails)                if (userIds.isEmpty()) return emptyList()                val incomesList = mutableListOf<Income>()                val batchSize = 10                for (i in userIds.indices step batchSize) {                    val batch = userIds.subList(i, kotlin.math.min(i + batchSize, userIds.size))                    val querySnapshot = db.collection("incomes")                        .whereIn("userId", batch)                        .get()                        .await()                    incomesList.addAll(querySnapshot.toObjects(Income::class.java))                }                incomesList            } else {                val currentUserId = FirebaseAuth.getInstance().currentUser?.uid ?: return emptyList()                val querySnapshot = db.collection("incomes")                    .whereEqualTo("userId", currentUserId)                    .get()                    .await()                querySnapshot.toObjects(Income::class.java)            }        } catch (e: Exception) {            Log.e("StatsRepository", "Error al obtener los ingresos", e)            emptyList()        }    }    // Obtener grupos completos donde el usuario está, según email    suspend fun getUserGroups(): List<Group> {        val userEmail = FirebaseAuth.getInstance().currentUser?.email ?: return emptyList()        return try {            val snapshot = db.collection("groups")                .whereArrayContains("members", userEmail)                .get()                .await()            snapshot.documents.mapNotNull { doc ->                val group = doc.toObject(Group::class.java)                group?.id = doc.id                group            }        } catch (e: Exception) {            Log.e("StatsRepository", "Error al obtener grupos completos", e)            emptyList()        }    }    // Nuevo método auxiliar para obtener userIds a partir de emails    private suspend fun getUserIdsFromEmails(emails: List<String>): List<String> {        if (emails.isEmpty()) return emptyList()        val userIds = mutableListOf<String>()        try {            val batchSize = 10            for (i in emails.indices step batchSize) {                val batch = emails.subList(i, kotlin.math.min(i + batchSize, emails.size))                val querySnapshot = db.collection("users")                    .whereIn("email", batch)                    .get()                    .await()                val foundEmails = querySnapshot.documents.mapNotNull { it.getString("email") }                val missingEmails = batch.filter { it !in foundEmails }                if (missingEmails.isNotEmpty()) {                    Log.w("StatsRepository", "Emails no encontrados en usuarios: $missingEmails")                }                val ids = querySnapshot.documents.mapNotNull { it.id }                userIds.addAll(ids)            }        } catch (e: Exception) {            Log.e("StatsRepository", "Error al obtener userIds desde emails", e)        }        return userIds    }    suspend fun getUserNamesByIds(userIds: List<String>): Map<String, String> {        if (userIds.isEmpty()) return emptyMap()        val userNames = mutableMapOf<String, String>()        try {            val batchSize = 10            for (i in userIds.indices step batchSize) {                val batch = userIds.subList(i, kotlin.math.min(i + batchSize, userIds.size))                val querySnapshot = db.collection("users")                    .whereIn(FieldPath.documentId(), batch)                    .get()                    .await()                for (doc in querySnapshot.documents) {                    val name = doc.getString("name") ?: "Desconocido"                    userNames[doc.id] = name                }            }        } catch (e: Exception) {            Log.e("StatsRepository", "Error al obtener nombres de usuarios", e)        }        return userNames    }}