package com.example.app_jdp_gestion_gastos.data.repositoryimport android.util.Logimport com.example.app_jdp_gestion_gastos.data.model.Expenseimport com.example.app_jdp_gestion_gastos.data.model.Incomeimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.firestore.FirebaseFirestoreimport kotlinx.coroutines.tasks.await//REPOSITORIO PARA AÑADIR O ELIMINAR TRANSACCIONESclass TransactionsRepository {    private val db = FirebaseFirestore.getInstance()    private val auth = FirebaseAuth.getInstance()    suspend fun getIncomes(): List<Income> {        val userId = auth.currentUser?.uid ?: "usuario_demo"        return try {            db.collection("incomes").whereEqualTo("userId", userId).get().await()                .map { document ->                    val income = document.toObject(Income::class.java)                    income.id = document.id  // Asignar el ID del documento al campo 'id'                    income                }        } catch (e: Exception) {            emptyList()        }    }    suspend fun getExpenses(): List<Expense> {        val userId = auth.currentUser?.uid ?: "usuario_demo"        return try {            db.collection("expenses").whereEqualTo("userId", userId).get().await()                .map { document ->                    val expense = document.toObject(Expense::class.java)                    expense.id = document.id  // Asignar el ID del documento al campo 'id'                    expense                }        } catch (e: Exception) {            emptyList()        }    }    suspend fun addIncome(income: Income): Boolean {        return try {            val newDocRef = db.collection("incomes").add(income).await() // Agregar el documento            income.id = newDocRef.id  // Asignar el ID generado por Firebase al campo id            db.collection("incomes").document(newDocRef.id).set(income).await()  // Actualizar el documento con el ID            true        } catch (e: Exception) {            false        }    }    suspend fun addExpense(expense: Expense): Boolean {        return try {            val newDocRef = db.collection("expenses").add(expense).await() // Agregar el documento            expense.id = newDocRef.id  // Asignar el ID generado por Firebase al campo id            db.collection("expenses").document(newDocRef.id).set(expense).await()  // Actualizar el documento con el ID            true        } catch (e: Exception) {            false        }    }    suspend fun deleteTransaction(transactionId: String): Boolean {        return try {            val incomeDoc = db.collection("incomes").document(transactionId)            val expenseDoc = db.collection("expenses").document(transactionId)            // Verificar si el documento existe antes de intentar eliminarlo            val incomeExists = incomeDoc.get().await().exists()            val expenseExists = expenseDoc.get().await().exists()            if (incomeExists) incomeDoc.delete().await()            if (expenseExists) expenseDoc.delete().await()            true        } catch (e: Exception) {            Log.e("TransactionsRepository", "Error al eliminar la transacción: ${e.message}")            false        }    }}