package com.example.app_jdp_gestion_gastos.data.repositoryimport android.util.Logimport com.example.app_jdp_gestion_gastos.data.model.Expenseimport com.example.app_jdp_gestion_gastos.data.model.Groupimport com.example.app_jdp_gestion_gastos.data.model.Incomeimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.firestore.FirebaseFirestoreimport kotlinx.coroutines.tasks.awaitimport java.util.*class GroupChartRepository {    private val db = FirebaseFirestore.getInstance()    private val auth = FirebaseAuth.getInstance()    // Método privado para obtener userIds desde los emails de los miembros del grupo    private suspend fun getUserIdsFromGroup(groupId: String): List<String> {        return try {            val groupSnapshot = db.collection("groups").document(groupId).get().await()            val group = groupSnapshot.toObject(Group::class.java)            val emails = group?.members ?: emptyList()            if (emails.isEmpty()) return emptyList()            val userIds = mutableListOf<String>()            val batchSize = 10            for (i in emails.indices step batchSize) {                val batch = emails.subList(i, kotlin.math.min(i + batchSize, emails.size))                val querySnapshot = db.collection("users")                    .whereIn("email", batch)                    .get()                    .await()                userIds.addAll(querySnapshot.documents.map { it.id })            }            userIds        } catch (e: Exception) {            Log.e("GroupChartRepository", "Error getting userIds from group", e)            emptyList()        }    }    suspend fun getExpenses(month: Int, year: Int, groupId: String? = null): List<Expense> {        val startDate = Calendar.getInstance().apply {            set(year, month, 1, 0, 0, 0)            set(Calendar.MILLISECOND, 0)        }.time        val endDate = Calendar.getInstance().apply {            set(year, month, 1, 23, 59, 59)            add(Calendar.MONTH, 1)            set(Calendar.MILLISECOND, 0)        }.time        return try {            if (groupId != null) {                val userIds = getUserIdsFromGroup(groupId)                if (userIds.isEmpty()) return emptyList()                val expensesList = mutableListOf<Expense>()                val batchSize = 10                for (i in userIds.indices step batchSize) {                    val batch = userIds.subList(i, kotlin.math.min(i + batchSize, userIds.size))                    val querySnapshot = db.collection("expenses")                        .whereIn("userId", batch)                        .whereGreaterThanOrEqualTo("date", startDate)                        .whereLessThan("date", endDate)                        .get()                        .await()                    expensesList.addAll(querySnapshot.toObjects(Expense::class.java))                }                expensesList            } else {                val currentUserId = auth.currentUser?.uid ?: return emptyList()                val snapshot = db.collection("expenses")                    .whereEqualTo("userId", currentUserId)                    .whereGreaterThanOrEqualTo("date", startDate)                    .whereLessThan("date", endDate)                    .get()                    .await()                snapshot.toObjects(Expense::class.java)            }        } catch (e: Exception) {            Log.e("GroupChartRepository", "Error getting expenses", e)            emptyList()        }    }    suspend fun getIncomes(month: Int, year: Int, groupId: String? = null): List<Income> {        val startDate = Calendar.getInstance().apply {            set(year, month, 1, 0, 0, 0)            set(Calendar.MILLISECOND, 0)        }.time        val endDate = Calendar.getInstance().apply {            set(year, month, 1, 23, 59, 59)            add(Calendar.MONTH, 1)            set(Calendar.MILLISECOND, 0)        }.time        return try {            if (groupId != null) {                val userIds = getUserIdsFromGroup(groupId)                if (userIds.isEmpty()) return emptyList()                val incomesList = mutableListOf<Income>()                val batchSize = 10                for (i in userIds.indices step batchSize) {                    val batch = userIds.subList(i, kotlin.math.min(i + batchSize, userIds.size))                    val querySnapshot = db.collection("incomes")                        .whereIn("userId", batch)                        .whereGreaterThanOrEqualTo("date", startDate)                        .whereLessThan("date", endDate)                        .get()                        .await()                    incomesList.addAll(querySnapshot.toObjects(Income::class.java))                }                incomesList            } else {                val currentUserId = auth.currentUser?.uid ?: return emptyList()                val snapshot = db.collection("incomes")                    .whereEqualTo("userId", currentUserId)                    .whereGreaterThanOrEqualTo("date", startDate)                    .whereLessThan("date", endDate)                    .get()                    .await()                snapshot.toObjects(Income::class.java)            }        } catch (e: Exception) {            Log.e("GroupChartRepository", "Error getting incomes", e)            emptyList()        }    }    suspend fun getGroupIdByUserEmail(email: String): String? {        return try {            val querySnapshot = db.collection("groups")                .whereArrayContains("members", email)                .get()                .await()            if (!querySnapshot.isEmpty) {                querySnapshot.documents[0].id // Devuelve el id del primer grupo donde está el email            } else {                null // No encontró ningún grupo con ese email            }        } catch (e: Exception) {            Log.e("GroupChartRepository", "Error getting groupId by user email", e)            null        }    }}