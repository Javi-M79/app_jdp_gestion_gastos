package com.example.app_jdp_gestion_gastos.ui.dialogimport android.app.Dialogimport android.graphics.Colorimport android.os.Bundleimport android.text.Spannableimport android.text.SpannableStringimport android.text.SpannableStringBuilderimport android.text.style.ForegroundColorSpanimport android.util.Logimport android.view.Windowimport android.widget.Buttonimport android.widget.TextViewimport androidx.fragment.app.DialogFragmentimport com.example.app_jdp_gestion_gastos.Rimport com.example.app_jdp_gestion_gastos.data.model.Expenseimport com.example.app_jdp_gestion_gastos.data.model.Incomeimport com.google.firebase.Timestampimport java.text.SimpleDateFormatimport java.util.Dateimport java.util.Localeclass CalendaryDialog(    private val selectedDate: String,    private var incomes: List<Income>,    private var expenses: List<Expense>) : DialogFragment() {    private var onDismissListener: (() -> Unit)? = null    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {        val dialog = Dialog(requireContext())        dialog.requestWindowFeature(Window.FEATURE_NO_TITLE)        dialog.setContentView(R.layout.dialog_transactions)        dialog.window?.setBackgroundDrawableResource(android.R.color.transparent)        val titleTextView = dialog.findViewById<TextView>(R.id.tvDialogTitle)        val detailsTextView = dialog.findViewById<TextView>(R.id.tvTransactionDetails)        val closeButton = dialog.findViewById<Button>(R.id.btnClose)        titleTextView.text = "Transacciones del $selectedDate"        // Filtra las transacciones por la fecha seleccionada        val filteredIncomes = filterTransactionsByDate(incomes, selectedDate)        val filteredExpenses = filterTransactionsByDate(expenses, selectedDate)        updateTransactionDetails(detailsTextView, filteredIncomes as List<Income>, filteredExpenses as List<Expense>)        closeButton.setOnClickListener {            dismiss()        }        return dialog    }    // Filtra las transacciones por la fecha seleccionada    private fun filterTransactionsByDate(transactions: List<Any>, selectedDate: String): List<Any> {        val filteredList = mutableListOf<Any>()        transactions.forEach {            when (it) {                is Income -> {                    val transactionDate = it.date?.toDate()                    if (transactionDate != null && formatDate(transactionDate) == selectedDate) {                        filteredList.add(it)                    }                }                is Expense -> {                    val transactionDate = it.date?.toDate()                    if (transactionDate != null && formatDate(transactionDate) == selectedDate) {                        filteredList.add(it)                    }                }            }        }        return filteredList    }    // Convierte la fecha a un formato de tipo "dd-MM-yyyy"    private fun formatDate(date: Date): String {        val sdf = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())        return sdf.format(date)    }    private fun updateTransactionDetails(detailsTextView: TextView, filteredIncomes: List<Income>, filteredExpenses: List<Expense>) {        val spannableBuilder = SpannableStringBuilder()        Log.d("CalendaryDialog", "Ingresos: ${filteredIncomes.size}, Gastos: ${filteredExpenses.size}")        if (filteredIncomes.isEmpty() && filteredExpenses.isEmpty()) {            spannableBuilder.append("No hay transacciones para esta fecha.")        } else {            filteredIncomes.forEach { income ->                val transactionText = "Ingreso - ${income.name}: ${"%.2f".format(income.amount)} €\n"                val spannableString = SpannableString(transactionText).apply {                    setSpan(                        ForegroundColorSpan(Color.GREEN),                        0, length,                        Spannable.SPAN_EXCLUSIVE_EXCLUSIVE                    )                }                spannableBuilder.append(spannableString)            }            filteredExpenses.forEach { expense ->                val transactionText = "Gasto - ${expense.name}: ${"%.2f".format(expense.amount)} €\n"                val spannableString = SpannableString(transactionText).apply {                    setSpan(                        ForegroundColorSpan(Color.RED),                        0, length,                        Spannable.SPAN_EXCLUSIVE_EXCLUSIVE                    )                }                spannableBuilder.append(spannableString)            }        }        detailsTextView.text = spannableBuilder    }    fun updateData(newIncomes: List<Income>, newExpenses: List<Expense>) {        incomes = newIncomes        expenses = newExpenses        dialog?.findViewById<TextView>(R.id.tvTransactionDetails)?.let { detailsTextView ->            // Filtra las nuevas transacciones antes de actualizar            val filteredIncomes = filterTransactionsByDate(newIncomes, selectedDate)            val filteredExpenses = filterTransactionsByDate(newExpenses, selectedDate)            updateTransactionDetails(detailsTextView, filteredIncomes as List<Income>, filteredExpenses as List<Expense>)        }        Log.d("CalendaryDialog", "updateData ejecutado: Ingresos=${incomes.size}, Gastos=${expenses.size}")    }    fun setOnDismissListener(listener: () -> Unit) {        onDismissListener = listener    }    override fun onDismiss(dialog: android.content.DialogInterface) {        super.onDismiss(dialog)        onDismissListener?.invoke()    }}