package com.example.app_jdp_gestion_gastos.ui.viewmodelimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.example.app_jdp_gestion_gastos.data.repository.StatsRepositoryimport kotlinx.coroutines.launchimport java.util.Calendarimport java.text.SimpleDateFormatimport java.util.Localeclass StatsViewModel(private val statsRepository: StatsRepository) : ViewModel() {    private var selectedMonth: Int? = null    private var selectedYear: Int = Calendar.getInstance().get(Calendar.YEAR)    private val _totalGastos = MutableLiveData<Double>()    val totalGastos: LiveData<Double> get() = _totalGastos    private val _totalIngresos = MutableLiveData<Double>()    val totalIngresos: LiveData<Double> get() = _totalIngresos    private val _promedioGastos = MutableLiveData<Double>()    val promedioGastos: LiveData<Double> get() = _promedioGastos    private val _numTransaccionesIngresos = MutableLiveData<Int>()    val numTransaccionesIngresos: LiveData<Int> get() = _numTransaccionesIngresos    private val _numTransaccionesGastos = MutableLiveData<Int>()    val numTransaccionesGastos: LiveData<Int> get() = _numTransaccionesGastos    fun loadStats() {        viewModelScope.launch {            val expenses = statsRepository.getExpenses()            val incomes = statsRepository.getIncomes()            val currentCalendar = Calendar.getInstance()            val currentMonth = currentCalendar.get(Calendar.MONTH)            val currentYear = currentCalendar.get(Calendar.YEAR)            val currentMonthExpenses = expenses.filter { expense ->                expense.date?.toDate()?.let {                    val calendar = Calendar.getInstance().apply { time = it }                    calendar.get(Calendar.MONTH) == currentMonth &&                            calendar.get(Calendar.YEAR) == currentYear                } ?: false            }            val currentMonthIncomes = incomes.filter { income ->                income.date?.toDate()?.let {                    val calendar = Calendar.getInstance().apply { time = it }                    calendar.get(Calendar.MONTH) == currentMonth &&                            calendar.get(Calendar.YEAR) == currentYear                } ?: false            }            val totalExpensesAmount = currentMonthExpenses.sumOf { it.amount }            val totalIncomesAmount = currentMonthIncomes.sumOf { it.amount }            val monthlyBalance = totalIncomesAmount - totalExpensesAmount            _totalGastos.postValue(totalExpensesAmount)            _totalIngresos.postValue(totalIncomesAmount)            _promedioGastos.postValue(monthlyBalance)            _numTransaccionesGastos.postValue(currentMonthExpenses.size)            _numTransaccionesIngresos.postValue(currentMonthIncomes.size)        }    }    fun loadStatsForMonth(month: Int?, year: Int = Calendar.getInstance().get(Calendar.YEAR)) {        selectedMonth = month        selectedYear = year        viewModelScope.launch {            val expenses = statsRepository.getExpenses()            val incomes = statsRepository.getIncomes()            val filteredExpenses = expenses.filter { expense ->                expense.date?.toDate()?.let {                    val cal = Calendar.getInstance().apply { time = it }                    (month == null || cal.get(Calendar.MONTH) == month) && cal.get(Calendar.YEAR) == year                } ?: false            }            val filteredIncomes = incomes.filter { income ->                income.date?.toDate()?.let {                    val cal = Calendar.getInstance().apply { time = it }                    (month == null || cal.get(Calendar.MONTH) == month) && cal.get(Calendar.YEAR) == year                } ?: false            }            _totalGastos.postValue(filteredExpenses.sumOf { it.amount })            _totalIngresos.postValue(filteredIncomes.sumOf { it.amount })            _promedioGastos.postValue(filteredIncomes.sumOf { it.amount } - filteredExpenses.sumOf { it.amount })            _numTransaccionesGastos.postValue(filteredExpenses.size)            _numTransaccionesIngresos.postValue(filteredIncomes.size)        }    }    fun getIncomesForMonth(callback: (List<String>) -> Unit) {        viewModelScope.launch {            val incomes = statsRepository.getIncomes()            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())            val filtered = incomes.filter { income ->                income.date?.toDate()?.let {                    val cal = Calendar.getInstance().apply { time = it }                    (selectedMonth == null || cal.get(Calendar.MONTH) == selectedMonth) &&                            cal.get(Calendar.YEAR) == selectedYear                } ?: false            }            val result = filtered.map { income ->                val formattedDate = income.date?.toDate()?.let { dateFormat.format(it) } ?: "Sin fecha"                "- Tipo: ${income.name}\n- Cantidad: ${"%.2f".format(income.amount)} €\n- Fecha: $formattedDate"            }            callback(result)        }    }    fun getExpensesForMonth(callback: (List<String>) -> Unit) {        viewModelScope.launch {            val expenses = statsRepository.getExpenses()            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())            val filtered = expenses.filter { expense ->                expense.date?.toDate()?.let {                    val cal = Calendar.getInstance().apply { time = it }                    (selectedMonth == null || cal.get(Calendar.MONTH) == selectedMonth) &&                            cal.get(Calendar.YEAR) == selectedYear                } ?: false            }            val result = filtered.map { expense ->                val formattedDate = expense.date?.toDate()?.let { dateFormat.format(it) } ?: "Sin fecha"                "- Tipo: ${expense.name}\n- Cantidad: ${"%.2f".format(expense.amount)} €\n - Fecha: $formattedDate"            }            callback(result)        }    }}