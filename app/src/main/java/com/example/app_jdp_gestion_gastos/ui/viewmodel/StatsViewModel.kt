package com.example.app_jdp_gestion_gastos.ui.viewmodelimport android.util.Logimport androidx.lifecycle.*import com.example.app_jdp_gestion_gastos.data.model.Groupimport com.example.app_jdp_gestion_gastos.data.repository.StatsRepositoryimport com.google.firebase.firestore.FieldPathimport kotlinx.coroutines.launchimport java.text.SimpleDateFormatimport java.util.*class StatsViewModel(private val statsRepository: StatsRepository) : ViewModel() {    // LiveData para lista de grupos completos (con id y nombre)    private val _userGroups = MutableLiveData<List<Group>>()    val userGroups: LiveData<List<Group>> get() = _userGroups    private var selectedMonth: Int? = null    private var selectedYear: Int = Calendar.getInstance().get(Calendar.YEAR)    var selectedGroupId: String? = null        private set    private var esGrupo: Boolean = false    private val _totalGastos = MutableLiveData<Double>()    val totalGastos: LiveData<Double> get() = _totalGastos    private val _totalIngresos = MutableLiveData<Double>()    val totalIngresos: LiveData<Double> get() = _totalIngresos    private val _promedioGastos = MutableLiveData<Double>()    val promedioGastos: LiveData<Double> get() = _promedioGastos    private val _numTransaccionesIngresos = MutableLiveData<Int>()    val numTransaccionesIngresos: LiveData<Int> get() = _numTransaccionesIngresos    private val _numTransaccionesGastos = MutableLiveData<Int>()    val numTransaccionesGastos: LiveData<Int> get() = _numTransaccionesGastos    // Carga grupos completos con id y nombre, y asigna selectedGroupId al primero si es grupo    fun loadUserGroups() {        viewModelScope.launch {            val grupos = statsRepository.getUserGroups()            _userGroups.postValue(grupos)            if (esGrupo) {                selectedGroupId = grupos.firstOrNull()?.id            }        }    }    // Setea si es grupo o no, y carga los grupos si es grupo    fun setGrupoSeleccionado(esGrupo: Boolean) {        this.esGrupo = esGrupo        if (esGrupo) {            loadUserGroups()        } else {            selectedGroupId = null        }    }    // Permite cambiar el grupo seleccionado desde la UI (por ejemplo al seleccionar en spinner)    fun setSelectedGroupId(groupId: String?) {        selectedGroupId = groupId    }    fun loadStats() {        val month = Calendar.getInstance().get(Calendar.MONTH)        val year = Calendar.getInstance().get(Calendar.YEAR)        loadStatsForMonth(month, year)    }    fun loadStatsForMonth(month: Int?, year: Int = Calendar.getInstance().get(Calendar.YEAR)) {        selectedMonth = month        selectedYear = year        viewModelScope.launch {            val expenses = statsRepository.getExpenses(selectedGroupId)            val incomes = statsRepository.getIncomes(selectedGroupId)            val filteredExpenses = expenses.filter { it.date?.toDate()?.let { d ->                val cal = Calendar.getInstance().apply { time = d }                (month == null || cal.get(Calendar.MONTH) == month) && cal.get(Calendar.YEAR) == year            } ?: false }            val filteredIncomes = incomes.filter { it.date?.toDate()?.let { d ->                val cal = Calendar.getInstance().apply { time = d }                (month == null || cal.get(Calendar.MONTH) == month) && cal.get(Calendar.YEAR) == year            } ?: false }            _totalGastos.postValue(filteredExpenses.sumOf { it.amount })            _totalIngresos.postValue(filteredIncomes.sumOf { it.amount })            _promedioGastos.postValue(filteredIncomes.sumOf { it.amount } - filteredExpenses.sumOf { it.amount })            _numTransaccionesGastos.postValue(filteredExpenses.size)            _numTransaccionesIngresos.postValue(filteredIncomes.size)        }    }    fun getIncomesForMonth(callback: (List<String>) -> Unit) {        viewModelScope.launch {            val incomes = statsRepository.getIncomes(selectedGroupId)            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())            val filtered = incomes.filter { it.date?.toDate()?.let { d ->                val cal = Calendar.getInstance().apply { time = d }                (selectedMonth == null || cal.get(Calendar.MONTH) == selectedMonth) &&                        cal.get(Calendar.YEAR) == selectedYear            } ?: false }            val userIds = filtered.mapNotNull { it.userId }.distinct()            val userNamesMap = statsRepository.getUserNamesByIds(userIds)            val result = filtered.map {                val dateStr = it.date?.toDate()?.let { d -> dateFormat.format(d) } ?: "Sin fecha"                val userName = userNamesMap[it.userId] ?: "Desconocido"                "- Tipo: ${it.name}\n- Cantidad: ${"%.2f".format(it.amount)} €\n- Fecha: $dateStr \n- Usuario: $userName"            }            callback(result)        }    }    fun getExpensesForMonth(callback: (List<String>) -> Unit) {        viewModelScope.launch {            val expenses = statsRepository.getExpenses(selectedGroupId)            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())            val filtered = expenses.filter { it.date?.toDate()?.let { d ->                val cal = Calendar.getInstance().apply { time = d }                (selectedMonth == null || cal.get(Calendar.MONTH) == selectedMonth) &&                        cal.get(Calendar.YEAR) == selectedYear            } ?: false }            val userIds = filtered.mapNotNull { it.userId }.distinct()            val userNamesMap = statsRepository.getUserNamesByIds(userIds)            val result = filtered.map {                val dateStr = it.date?.toDate()?.let { d -> dateFormat.format(d) } ?: "Sin fecha"                val userName = userNamesMap[it.userId] ?: "Desconocido"                "- Tipo: ${it.name}\n- Cantidad: ${"%.2f".format(it.amount)} €\n - Fecha: $dateStr \n- Usuario: $userName"            }            callback(result)        }    }}