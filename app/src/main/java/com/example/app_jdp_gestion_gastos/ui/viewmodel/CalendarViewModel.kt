package com.example.app_jdp_gestion_gastos.ui.viewmodelimport CalendarRepositoryimport android.util.Logimport androidx.lifecycle.LiveDataimport androidx.lifecycle.MutableLiveDataimport androidx.lifecycle.ViewModelimport com.example.app_jdp_gestion_gastos.data.model.Expenseimport com.example.app_jdp_gestion_gastos.data.model.Incomeimport com.google.firebase.Timestampimport com.google.firebase.firestore.FirebaseFirestoreimport java.text.SimpleDateFormatimport java.util.*class CalendarViewModel : ViewModel() {    private val repository = CalendarRepository()    private val _incomeTransactions = MutableLiveData<List<Income>>()    val incomeTransactions: LiveData<List<Income>> get() = _incomeTransactions    private val _expenseTransactions = MutableLiveData<List<Expense>>()    val expenseTransactions: LiveData<List<Expense>> get() = _expenseTransactions    private var activeDate: String? = null    private var activeUserId: String? = null    // Asegúrate de que los ingresos y gastos se carguen antes de hacer la actualización    fun loadTransactionsForDate(date: String, userId: String, callback: (List<Income>, List<Expense>) -> Unit) {        if (date == activeDate && userId == activeUserId) {            Log.d("CalendarViewModel", "→ Ya cargadas las transacciones para $date y usuario $userId")            return // No cargar nuevamente si ya se cargaron para esta fecha y usuario        }        val timestamp = convertToTimestamp(date)        activeDate = date        activeUserId = userId        Log.d("CalendarViewModel", "→ Cargando transacciones para $date y usuario $userId")        // Inicializar el estado de carga        incomesLoaded = false        expensesLoaded = false        repository.getIncomeForDate(timestamp, userId) { incomes ->            Log.d("CalendarViewModel", "→ Ingresos obtenidos: ${incomes.size}")            if (date == activeDate && userId == activeUserId) {                _incomeTransactions.postValue(incomes)            }            checkIfBothLoaded(callback)        }        repository.getExpenseForDate(timestamp, userId) { expenses ->            Log.d("CalendarViewModel", "→ Gastos obtenidos: ${expenses.size}")            if (date == activeDate && userId == activeUserId) {                _expenseTransactions.postValue(expenses)            }            checkIfBothLoaded(callback)        }    }    private var incomesLoaded: Boolean = false    private var expensesLoaded: Boolean = false    private fun checkIfBothLoaded(callback: (List<Income>, List<Expense>) -> Unit) {        if (incomesLoaded && expensesLoaded) {            // Llamar al callback una vez que ambos datos estén disponibles            callback(_incomeTransactions.value ?: emptyList(), _expenseTransactions.value ?: emptyList())        }    }    fun addIncome(income: Income) {        repository.saveIncome(income) { success ->            if (success) {                Log.d("CalendarViewModel", "Ingreso guardado exitosamente")            } else {                Log.e("CalendarViewModel", "Error al guardar ingreso")            }        }    }    fun addExpense(expense: Expense) {        repository.saveExpense(expense) { success ->            if (success) {                Log.d("CalendarViewModel", "Gasto guardado exitosamente")            } else {                Log.e("CalendarViewModel", "Error al guardar gasto")            }        }    }    fun loadAllTransactions(userId: String) {        repository.getAllIncomes(userId) { incomes ->            _incomeTransactions.postValue(incomes)        }        repository.getAllExpenses(userId) { expenses ->            _expenseTransactions.postValue(expenses)        }    }    fun clearIncomeTransactions() {        _incomeTransactions.value = emptyList()    }    fun clearExpenseTransactions() {        _expenseTransactions.value = emptyList()    }    fun loadIncomesForDate(date: String, userId: String) {        // Convertir la fecha seleccionada en un objeto Date        val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())        dateFormat.timeZone = TimeZone.getTimeZone("UTC") // Asegurarse de que la zona horaria sea UTC        val selectedDate = dateFormat.parse(date)        // Obtener el inicio del día (00:00:00)        val calendarStart = Calendar.getInstance().apply {            time = selectedDate            set(Calendar.HOUR_OF_DAY, 0)            set(Calendar.MINUTE, 0)            set(Calendar.SECOND, 0)            set(Calendar.MILLISECOND, 0)            timeZone = TimeZone.getTimeZone("UTC")        }        val startOfDay = Timestamp(calendarStart.time)        // Obtener el final del día (23:59:59.999)        val calendarEnd = Calendar.getInstance().apply {            time = selectedDate            set(Calendar.HOUR_OF_DAY, 23)            set(Calendar.MINUTE, 59)            set(Calendar.SECOND, 59)            set(Calendar.MILLISECOND, 999)            timeZone = TimeZone.getTimeZone("UTC")        }        val endOfDay = Timestamp(calendarEnd.time)        // Realizar la consulta de Firebase solo para ingresos del día seleccionado        FirebaseFirestore.getInstance().collection("transactions")            .whereEqualTo("userId", userId) // Filtrar por userId            .whereEqualTo("category", "Ingresos") // Asegurarse de que solo se traigan los ingresos            .whereGreaterThanOrEqualTo("date", startOfDay) // Filtrar por fecha de inicio            .whereLessThanOrEqualTo("date", endOfDay) // Filtrar por fecha de fin            .get()            .addOnSuccessListener { documents ->                val incomes = documents.mapNotNull { document ->                    val income = document.toObject(Income::class.java)                    income                }                Log.d("CalendaryDialog", "Incomes: $incomes")                _incomeTransactions.value = incomes // Actualizar UI o ViewModel            }            .addOnFailureListener { exception ->                Log.e("Firebase", "Error al obtener documentos de ingresos: ", exception)            }    }    fun loadExpensesForDate(date: String, userId: String) {        // Convertir la fecha seleccionada en un objeto Date        val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())        dateFormat.timeZone = TimeZone.getTimeZone("UTC") // Asegurarse de que la zona horaria sea UTC        val selectedDate = dateFormat.parse(date)        // Obtener el inicio del día (00:00:00)        val calendarStart = Calendar.getInstance().apply {            time = selectedDate            set(Calendar.HOUR_OF_DAY, 0)            set(Calendar.MINUTE, 0)            set(Calendar.SECOND, 0)            set(Calendar.MILLISECOND, 0)            timeZone = TimeZone.getTimeZone("UTC")        }        val startOfDay = Timestamp(calendarStart.time)        // Obtener el final del día (23:59:59.999)        val calendarEnd = Calendar.getInstance().apply {            time = selectedDate            set(Calendar.HOUR_OF_DAY, 23)            set(Calendar.MINUTE, 59)            set(Calendar.SECOND, 59)            set(Calendar.MILLISECOND, 999)            timeZone = TimeZone.getTimeZone("UTC")        }        val endOfDay = Timestamp(calendarEnd.time)        // Realizar la consulta de Firebase solo para gastos del día seleccionado        FirebaseFirestore.getInstance().collection("transactions")            .whereEqualTo("userId", userId) // Filtrar por userId            .whereEqualTo("category", "Gastos") // Asegurarse de que solo se traigan los gastos            .whereGreaterThanOrEqualTo("date", startOfDay) // Filtrar por fecha de inicio            .whereLessThanOrEqualTo("date", endOfDay) // Filtrar por fecha de fin            .get()            .addOnSuccessListener { documents ->                val expenses = documents.mapNotNull { document ->                    val expense = document.toObject(Expense::class.java)                    expense                }                Log.d("CalendaryDialog", "Expenses: $expenses")                _expenseTransactions.value = expenses // Actualizar UI o ViewModel            }            .addOnFailureListener { exception ->                Log.e("Firebase", "Error al obtener documentos de gastos: ", exception)            }    }    private fun convertToTimestamp(dateString: String): Timestamp {        return try {            val dateFormat = SimpleDateFormat("dd-MM-yyyy", Locale.getDefault())            val date = dateFormat.parse(dateString)            Timestamp(date!!)        } catch (e: Exception) {            Log.e("CalendarViewModel", "❌ Error al convertir fecha: $e")            Timestamp(Date())        }    }}